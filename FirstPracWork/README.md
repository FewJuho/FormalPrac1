Решим задачу используя динамику в трехмерном векторе.

Размер первого измерения равен длине регулярки, второго и третьего - длине слова.
Элементы вектора (bool) показывают достижимость подслова из префикса регулярки, длина
которого равна значению в первой координате вектора. (Изначально false везде)
Так же заведем стэк номеров концов регулярок, которые не обрабатываем сразу.

Рассмотрим различные возможные операции в регулярном выражении:
POS - номер в 0 индексации символа в регулярке

Пусть '+':
Смотрим на арность, она равна 2, значит берем из стека два номера.
Если подслово достижимо из хотя бы одной регулярки, то присваиваем true.

Пусть '.':
Смотрим на арность, она равна 2, значит берем из стека два номера.
Если подслово можно разделить на два меньших, которые являются достижимыми, то ставим true.

//  word[i...j) = word[i...mid) + word[mid...j)

Пусть '*':
Смотрим на арность, она равна 1, значит берем из стека один номер.
Для всех элементов Vector[pos][i][i] ставим true, достижимость очевидна.
Затем пытаемся разбить подслово на конкатенацию меньших, каждое из которых достижимо из 
Vector[pos][*][*]

// word[i...j) = word[i...mid1) + word[mid1...mid2) + ... + word[mid_last...j)

то есть можем разбить на два слова так, что первое достижимо из stack.top(), а
второе из Vector[pos][*][*].

Пусть else:
Если '1', то для всех элементов Vector[pos][i][i] ставим true, достижимость очевидна.

Если же {a,b,c}, то достижимость следующего очевидна, то есть Vector[pos][i]i* + 1] = true.

Ответ считаем проходом по Vector[Lenght - 1] (по всему слову) и поиском максимального значения 
разности между true значениями.